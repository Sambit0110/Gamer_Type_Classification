# -*- coding: utf-8 -*-
"""Gamer_Type_Classification_for_PlayArena.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FWLSrjdSlPdYQYNk9VmGSHFAN2R781q1
"""

# ðŸ“˜ Gamer Type Classification for PlayArena
print('Hello from YBI Foundation ðŸš€')

"""## **Importing Libraries**"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

"""## Load the Dataset"""

df = pd.read_csv('/content/Gamer Type Classification for PlayArena.csv')

df.head()

df.shape

df.info()

df['PreferredGenre'].value_counts()

df['GamerType'].value_counts()

"""## Data Preprocessing
- **GamerType, PreferredGenre** are Categorical columns.
- **One Hot Encoding** of categorical columns.
"""

df_new = pd.get_dummies(df,columns=['GamerType','PreferredGenre'],drop_first=True)

df_new.head()

df_new.info()

df = df_new[['GamerID', 'PreferredGenre_Adventure', 'PreferredGenre_Puzzle', 'PreferredGenre_RPG', 'PreferredGenre_Shooter', 'PreferredGenre_Simulation', 'PreferredGenre_Sports', 'AvgSessionTimeMins', 'SessionsPerWeek', 'InGamePurchases', 'AchievementsUnlocked', 'FriendsInNetwork', 'PrefersMultiplayer', 'UsesVoiceChat', 'StreamingHoursPerWeek', 'GamerType_Casual', 'GamerType_Strategist', 'GamerType_Socializer', 'GamerType_Explorer']]

df.head()

df.shape

df[['GamerType_Casual', 'GamerType_Strategist', 'GamerType_Socializer', 'GamerType_Explorer', 'PreferredGenre_Adventure', 'PreferredGenre_Puzzle', 'PreferredGenre_RPG','PreferredGenre_Shooter', 'PreferredGenre_Simulation', 'PreferredGenre_Sports']] = df[['GamerType_Casual', 'GamerType_Strategist', 'GamerType_Socializer', 'GamerType_Explorer', 'PreferredGenre_Adventure', 'PreferredGenre_Puzzle', 'PreferredGenre_RPG','PreferredGenre_Shooter', 'PreferredGenre_Simulation', 'PreferredGenre_Sports']].astype(int)

df.info()

df.head()

df.corr()

df.describe()

"""## Exploratory Data Analysis (EDA)
- Pandas Profiling
"""

df.to_csv("classification.csv", index=False)

!pip install ydata-profiling

from ydata_profiling import ProfileReport

profile = ProfileReport(df, title="EDA Report", explorative=True)
profile.to_file("eda_report.html")
profile.to_notebook_iframe()

df['TotalPlaytime'] = df['AvgSessionTimeMins'] * df['SessionsPerWeek']

X = df.drop(['GamerID','GamerType_Casual','GamerType_Strategist','GamerType_Socializer','GamerType_Explorer'],axis=1)
y = df[['GamerType_Casual','GamerType_Strategist','GamerType_Socializer','GamerType_Explorer']]

onehot_cols = [col for col in X.columns if set(X[col].unique()) <= {0, 1}]
cont_cols = [col for col in X.columns if col not in onehot_cols]

# Step 2: Split the columns
X_onehot = X[onehot_cols]
X_cont = X[cont_cols]

X_onehot.head()

X_cont.head()

"""## Scale the Numeric Features"""

from sklearn.preprocessing import StandardScaler
scalar=StandardScaler()
X_cont_scaled = pd.DataFrame(scalar.fit_transform(X_cont), columns=cont_cols, index=X.index)

X_cont_scaled.head()

X_final = pd.concat([X_cont_scaled, X_onehot], axis=1)

X_final.head()

X_final.describe()

y = df[['GamerType_Casual','GamerType_Strategist','GamerType_Socializer','GamerType_Explorer']]

X_train, X_test, y_train, y_test = train_test_split(X_final, y, test_size=0.2, random_state=42)

"""### Classification Using ANN"""

import tensorflow as tf
from tensorflow import keras
from keras import Sequential
from keras.layers import Dense , Dropout ,BatchNormalization
from tensorflow.keras.optimizers import Adam, RMSprop

!pip install keras-tuner

"""### Hyperparameter Tuning Using Keras_tuner"""

import keras_tuner as kt

def build_model(hp):
    model = Sequential()
    count = 0

    for i in range(hp.Int('num_layers', min_value=1, max_value=3)):
        units = hp.Int('units' + str(i), min_value=8, max_value=64, step=8)
        activation = hp.Choice('activation' + str(i), values=['relu', 'tanh', 'sigmoid'])
        dropout_rate = hp.Choice('dropout' + str(i), values=[0.1 * i for i in range(1, 10)])

        if count == 0:
            model.add(Dense(units=units, activation=activation, input_dim=X_final.shape[1]))
        else:
            model.add(Dense(units=units, activation=activation))

        model.add(BatchNormalization())
        model.add(Dropout(dropout_rate))
        count += 1

    model.add(Dense(4, activation='softmax'))  # Classification output

    optimizer = hp.Choice('optimizer', values=['adam','rmsprop'])

    model.compile(
        optimizer=optimizer,
        loss='categorical_crossentropy',
        metrics=['accuracy']
    )

    return model

tuner = kt.RandomSearch(
    build_model,
    objective='val_accuracy',
    max_trials=10,
    executions_per_trial=1,
    directory='Project1',
    project_name='best_hyperparameters'
)

tuner.search(X_train, y_train, epochs=5, validation_data=(X_test, y_test))

tuner.get_best_hyperparameters()[0].values

model = tuner.get_best_models(num_models=1)[0]

model.summary()

model.fit(X_train, y_train, batch_size=32, epochs=50, validation_data=(X_test, y_test))

y_pred_ann = model.predict(X_test)

y_test_classes = np.argmax(y_test, axis=1)
y_pred_classes = np.argmax(y_pred_ann, axis=1)

print("Accuracy:", accuracy_score(y_test_classes, y_pred_classes))
print("\nClassification Report:\n", classification_report(y_test_classes, y_pred_classes))
print("\nConfusion Matrix:\n", confusion_matrix(y_test_classes, y_pred_classes))

"""## Classification Using Xgboost"""

gamer_type_columns  = [
    'GamerType_Casual',
    'GamerType_Strategist',
    'GamerType_Socializer',
    'GamerType_Explorer'
]

# Step 2: Identify rows where none of these 4 columns is 1 (implies missing class = Achiever)
df['GamerType_Label'] = df[gamer_type_columns].idxmax(axis=1)

# Step 3: Replace rows where all one-hot columns are 0 with the missing class name
df.loc[df[gamer_type_columns].sum(axis=1) == 0, 'GamerType_Label'] = 'GamerType_Achiever'

# Step 4: Final label mapping including the missing class
label_mapping = {
    'GamerType_Casual': 0,
    'GamerType_Strategist': 1,
    'GamerType_Socializer': 2,
    'GamerType_Explorer': 3,
    'GamerType_Achiever': 4  # This is the class that was dropped
}

df['GamerType_Label'] = df['GamerType_Label'].map(label_mapping)

y = df['GamerType_Label'].values

X_train, X_test, y_train, y_test = train_test_split(X_final, y, test_size=0.2, random_state=42)

import xgboost as xgb
from xgboost import XGBClassifier
from sklearn.metrics import classification_report, accuracy_score

# Instantiate the model
model = XGBClassifier(
    objective='multi:softprob',   # or 'multi:softmax' if you want predicted class directly
    num_class=len(set(y_train)),  # total number of classes
    eval_metric='mlogloss',       # standard for multi-class
    use_label_encoder=False,      # suppress warning in newer versions
    random_state=42
)

# Fit the model
model.fit(X_train, y_train)

# Predict probabilities or class
y_pred = model.predict(X_test)

# Evaluate
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

"""### Classification Using Logistic Regression"""

from sklearn.linear_model import LogisticRegression
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train.argmax(axis=1))
print("Accuracy:", model.score(X_test, y_test.argmax(axis=1)))

"""### Classification Using Randomforest"""

from sklearn.ensemble import RandomForestClassifier, VotingClassifier
y = y.argmax(axis=1)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
rf = RandomForestClassifier(n_estimators=100, random_state=42)
ensemble = VotingClassifier(estimators=[('lr', lr), ('rf', rf)], voting='hard')
ensemble.fit(X_train, y_train)
y_pred = ensemble.predict(X_test)
print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred))

from sklearn.svm import SVC
svm = SVC()
svm.fit(X_train, y_train)
y_pred_svm = svm.predict(X_test)

print("Accuracy:", accuracy_score(y_test, y_pred_svm))
print("\nClassification Report:\n", classification_report(y_test, y_pred_svm))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred_svm))

"""## Random Forest Algorithm Gives the best result."""

df.to_csv("preprocessed_dataset.csv", index=False)

